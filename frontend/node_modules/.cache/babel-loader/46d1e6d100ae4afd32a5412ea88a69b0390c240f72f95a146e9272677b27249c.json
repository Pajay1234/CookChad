{"ast":null,"code":"// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process;\nconst processOk = function (process) {\n  return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';\n};\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {\n    return function () {};\n  };\n} else {\n  var assert = require('assert');\n  var signals = require('./signals.js');\n  var isWin = /^win/i.test(process.platform);\n  var EE = require('events');\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter;\n  }\n  var emitter;\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__;\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE();\n    emitter.count = 0;\n    emitter.emitted = {};\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity);\n    emitter.infinite = true;\n  }\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return function () {};\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n    if (loaded === false) {\n      load();\n    }\n    var ev = 'exit';\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit';\n    }\n    var remove = function () {\n      emitter.removeListener(ev, cb);\n      if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {\n        unload();\n      }\n    };\n    emitter.on(ev, cb);\n    return remove;\n  };\n  var unload = function unload() {\n    if (!loaded || !processOk(global.process)) {\n      return;\n    }\n    loaded = false;\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    });\n    process.emit = originalProcessEmit;\n    process.reallyExit = originalProcessReallyExit;\n    emitter.count -= 1;\n  };\n  module.exports.unload = unload;\n  var emit = function emit(event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return;\n    }\n    emitter.emitted[event] = true;\n    emitter.emit(event, code, signal);\n  };\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {};\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener() {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return;\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig);\n      if (listeners.length === emitter.count) {\n        unload();\n        emit('exit', null, sig);\n        /* istanbul ignore next */\n        emit('afterexit', null, sig);\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT';\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig);\n      }\n    };\n  });\n  module.exports.signals = function () {\n    return signals;\n  };\n  var loaded = false;\n  var load = function load() {\n    if (loaded || !processOk(global.process)) {\n      return;\n    }\n    loaded = true;\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1;\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig]);\n        return true;\n      } catch (er) {\n        return false;\n      }\n    });\n    process.emit = processEmit;\n    process.reallyExit = processReallyExit;\n  };\n  module.exports.load = load;\n  var originalProcessReallyExit = process.reallyExit;\n  var processReallyExit = function processReallyExit(code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return;\n    }\n    process.exitCode = code || /* istanbul ignore next */0;\n    emit('exit', process.exitCode, null);\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null);\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode);\n  };\n  var originalProcessEmit = process.emit;\n  var processEmit = function processEmit(ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg;\n      }\n      var ret = originalProcessEmit.apply(this, arguments);\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null);\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null);\n      /* istanbul ignore next */\n      return ret;\n    } else {\n      return originalProcessEmit.apply(this, arguments);\n    }\n  };\n}","map":{"version":3,"names":["process","global","processOk","removeListener","emit","reallyExit","listeners","kill","pid","on","module","exports","assert","require","signals","isWin","test","platform","EE","EventEmitter","emitter","__signal_exit_emitter__","count","emitted","infinite","setMaxListeners","Infinity","cb","opts","equal","loaded","load","ev","alwaysLast","remove","length","unload","forEach","sig","sigListeners","er","originalProcessEmit","originalProcessReallyExit","event","code","signal","listener","filter","processEmit","processReallyExit","exitCode","call","arg","undefined","ret","apply","arguments"],"sources":["C:/Users/Ryan/Documents/school/fall 2023/cmpe 133/project/CookChad/frontend/node_modules/signal-exit/index.js"],"sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\r\n// that are in the direct sync flow of nyc's outputCoverage are\r\n// ignored, since we can never get coverage for them.\r\n// grab a reference to node's real process object right away\r\nvar process = global.process\r\n\r\nconst processOk = function (process) {\r\n  return process &&\r\n    typeof process === 'object' &&\r\n    typeof process.removeListener === 'function' &&\r\n    typeof process.emit === 'function' &&\r\n    typeof process.reallyExit === 'function' &&\r\n    typeof process.listeners === 'function' &&\r\n    typeof process.kill === 'function' &&\r\n    typeof process.pid === 'number' &&\r\n    typeof process.on === 'function'\r\n}\r\n\r\n// some kind of non-node environment, just no-op\r\n/* istanbul ignore if */\r\nif (!processOk(process)) {\r\n  module.exports = function () {\r\n    return function () {}\r\n  }\r\n} else {\r\n  var assert = require('assert')\r\n  var signals = require('./signals.js')\r\n  var isWin = /^win/i.test(process.platform)\r\n\r\n  var EE = require('events')\r\n  /* istanbul ignore if */\r\n  if (typeof EE !== 'function') {\r\n    EE = EE.EventEmitter\r\n  }\r\n\r\n  var emitter\r\n  if (process.__signal_exit_emitter__) {\r\n    emitter = process.__signal_exit_emitter__\r\n  } else {\r\n    emitter = process.__signal_exit_emitter__ = new EE()\r\n    emitter.count = 0\r\n    emitter.emitted = {}\r\n  }\r\n\r\n  // Because this emitter is a global, we have to check to see if a\r\n  // previous version of this library failed to enable infinite listeners.\r\n  // I know what you're about to say.  But literally everything about\r\n  // signal-exit is a compromise with evil.  Get used to it.\r\n  if (!emitter.infinite) {\r\n    emitter.setMaxListeners(Infinity)\r\n    emitter.infinite = true\r\n  }\r\n\r\n  module.exports = function (cb, opts) {\r\n    /* istanbul ignore if */\r\n    if (!processOk(global.process)) {\r\n      return function () {}\r\n    }\r\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\r\n\r\n    if (loaded === false) {\r\n      load()\r\n    }\r\n\r\n    var ev = 'exit'\r\n    if (opts && opts.alwaysLast) {\r\n      ev = 'afterexit'\r\n    }\r\n\r\n    var remove = function () {\r\n      emitter.removeListener(ev, cb)\r\n      if (emitter.listeners('exit').length === 0 &&\r\n          emitter.listeners('afterexit').length === 0) {\r\n        unload()\r\n      }\r\n    }\r\n    emitter.on(ev, cb)\r\n\r\n    return remove\r\n  }\r\n\r\n  var unload = function unload () {\r\n    if (!loaded || !processOk(global.process)) {\r\n      return\r\n    }\r\n    loaded = false\r\n\r\n    signals.forEach(function (sig) {\r\n      try {\r\n        process.removeListener(sig, sigListeners[sig])\r\n      } catch (er) {}\r\n    })\r\n    process.emit = originalProcessEmit\r\n    process.reallyExit = originalProcessReallyExit\r\n    emitter.count -= 1\r\n  }\r\n  module.exports.unload = unload\r\n\r\n  var emit = function emit (event, code, signal) {\r\n    /* istanbul ignore if */\r\n    if (emitter.emitted[event]) {\r\n      return\r\n    }\r\n    emitter.emitted[event] = true\r\n    emitter.emit(event, code, signal)\r\n  }\r\n\r\n  // { <signal>: <listener fn>, ... }\r\n  var sigListeners = {}\r\n  signals.forEach(function (sig) {\r\n    sigListeners[sig] = function listener () {\r\n      /* istanbul ignore if */\r\n      if (!processOk(global.process)) {\r\n        return\r\n      }\r\n      // If there are no other listeners, an exit is coming!\r\n      // Simplest way: remove us and then re-send the signal.\r\n      // We know that this will kill the process, so we can\r\n      // safely emit now.\r\n      var listeners = process.listeners(sig)\r\n      if (listeners.length === emitter.count) {\r\n        unload()\r\n        emit('exit', null, sig)\r\n        /* istanbul ignore next */\r\n        emit('afterexit', null, sig)\r\n        /* istanbul ignore next */\r\n        if (isWin && sig === 'SIGHUP') {\r\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\r\n          // so use a supported signal instead\r\n          sig = 'SIGINT'\r\n        }\r\n        /* istanbul ignore next */\r\n        process.kill(process.pid, sig)\r\n      }\r\n    }\r\n  })\r\n\r\n  module.exports.signals = function () {\r\n    return signals\r\n  }\r\n\r\n  var loaded = false\r\n\r\n  var load = function load () {\r\n    if (loaded || !processOk(global.process)) {\r\n      return\r\n    }\r\n    loaded = true\r\n\r\n    // This is the number of onSignalExit's that are in play.\r\n    // It's important so that we can count the correct number of\r\n    // listeners on signals, and don't wait for the other one to\r\n    // handle it instead of us.\r\n    emitter.count += 1\r\n\r\n    signals = signals.filter(function (sig) {\r\n      try {\r\n        process.on(sig, sigListeners[sig])\r\n        return true\r\n      } catch (er) {\r\n        return false\r\n      }\r\n    })\r\n\r\n    process.emit = processEmit\r\n    process.reallyExit = processReallyExit\r\n  }\r\n  module.exports.load = load\r\n\r\n  var originalProcessReallyExit = process.reallyExit\r\n  var processReallyExit = function processReallyExit (code) {\r\n    /* istanbul ignore if */\r\n    if (!processOk(global.process)) {\r\n      return\r\n    }\r\n    process.exitCode = code || /* istanbul ignore next */ 0\r\n    emit('exit', process.exitCode, null)\r\n    /* istanbul ignore next */\r\n    emit('afterexit', process.exitCode, null)\r\n    /* istanbul ignore next */\r\n    originalProcessReallyExit.call(process, process.exitCode)\r\n  }\r\n\r\n  var originalProcessEmit = process.emit\r\n  var processEmit = function processEmit (ev, arg) {\r\n    if (ev === 'exit' && processOk(global.process)) {\r\n      /* istanbul ignore else */\r\n      if (arg !== undefined) {\r\n        process.exitCode = arg\r\n      }\r\n      var ret = originalProcessEmit.apply(this, arguments)\r\n      /* istanbul ignore next */\r\n      emit('exit', process.exitCode, null)\r\n      /* istanbul ignore next */\r\n      emit('afterexit', process.exitCode, null)\r\n      /* istanbul ignore next */\r\n      return ret\r\n    } else {\r\n      return originalProcessEmit.apply(this, arguments)\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}