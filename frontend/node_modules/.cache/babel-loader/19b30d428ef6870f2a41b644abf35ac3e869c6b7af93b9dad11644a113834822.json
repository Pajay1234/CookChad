{"ast":null,"code":"'use strict';\n\nconst {\n  Minipass\n} = require('minipass');\nconst Pax = require('./pax.js');\nconst Header = require('./header.js');\nconst fs = require('fs');\nconst path = require('path');\nconst normPath = require('./normalize-windows-path.js');\nconst stripSlash = require('./strip-trailing-slashes.js');\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path);\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '');\n  return stripSlash(prefix) + '/' + path;\n};\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\nconst AWAITDRAIN = Symbol('awaitDrain');\nconst ONDRAIN = Symbol('ondrain');\nconst PREFIX = Symbol('prefix');\nconst HAD_ERROR = Symbol('hadError');\nconst warner = require('./warn-mixin.js');\nconst winchars = require('./winchars.js');\nconst stripAbsolutePath = require('./strip-absolute-path.js');\nconst modeFix = require('./mode-fix.js');\nconst WriteEntry = warner(class WriteEntry extends Minipass {\n  constructor(p, opt) {\n    opt = opt || {};\n    super(opt);\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required');\n    }\n    this.path = normPath(p);\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable;\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0;\n    this.myuser = process.env.USER || '';\n    this.maxReadSize = opt.maxReadSize || maxReadSize;\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.preservePaths = !!opt.preservePaths;\n    this.cwd = normPath(opt.cwd || process.cwd());\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null;\n    this.fd = null;\n    this.blockLen = null;\n    this.blockRemain = null;\n    this.buf = null;\n    this.offset = null;\n    this.length = null;\n    this.pos = null;\n    this.remain = null;\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn);\n    }\n    let pathWarn = false;\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path);\n      if (root) {\n        this.path = stripped;\n        pathWarn = root;\n      }\n    }\n    this.win32 = !!opt.win32 || process.platform === 'win32';\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p));\n    if (this.path === '') {\n      this.path = './';\n    }\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute));\n    } else {\n      this[LSTAT]();\n    }\n  }\n  emit(ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true;\n    }\n    return super.emit(ev, ...data);\n  }\n  [LSTAT]() {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er);\n      }\n      this[ONLSTAT](stat);\n    });\n  }\n  [ONLSTAT](stat) {\n    this.statCache.set(this.absolute, stat);\n    this.stat = stat;\n    if (!stat.isFile()) {\n      stat.size = 0;\n    }\n    this.type = getType(stat);\n    this.emit('stat', stat);\n    this[PROCESS]();\n  }\n  [PROCESS]() {\n    switch (this.type) {\n      case 'File':\n        return this[FILE]();\n      case 'Directory':\n        return this[DIRECTORY]();\n      case 'SymbolicLink':\n        return this[SYMLINK]();\n      // unsupported types are ignored.\n      default:\n        return this.end();\n    }\n  }\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n  [PREFIX](path) {\n    return prefixPath(path, this.prefix);\n  }\n  [HEADER]() {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true;\n    }\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    });\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode());\n    }\n    super.write(this.header.block);\n  }\n  [DIRECTORY]() {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/';\n    }\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n  [SYMLINK]() {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er);\n      }\n      this[ONREADLINK](linkpath);\n    });\n  }\n  [ONREADLINK](linkpath) {\n    this.linkpath = normPath(linkpath);\n    this[HEADER]();\n    this.end();\n  }\n  [HARDLINK](linkpath) {\n    this.type = 'Link';\n    this.linkpath = normPath(path.relative(this.cwd, linkpath));\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n  [FILE]() {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino;\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey);\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath);\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute);\n    }\n    this[HEADER]();\n    if (this.stat.size === 0) {\n      return this.end();\n    }\n    this[OPENFILE]();\n  }\n  [OPENFILE]() {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er);\n      }\n      this[ONOPENFILE](fd);\n    });\n  }\n  [ONOPENFILE](fd) {\n    this.fd = fd;\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]();\n    }\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n    this.blockRemain = this.blockLen;\n    const bufLen = Math.min(this.blockLen, this.maxReadSize);\n    this.buf = Buffer.allocUnsafe(bufLen);\n    this.offset = 0;\n    this.pos = 0;\n    this.remain = this.stat.size;\n    this.length = this.buf.length;\n    this[READ]();\n  }\n  [READ]() {\n    const {\n      fd,\n      buf,\n      offset,\n      length,\n      pos\n    } = this;\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er));\n      }\n      this[ONREAD](bytesRead);\n    });\n  }\n  [CLOSE](cb) {\n    fs.close(this.fd, cb);\n  }\n  [ONREAD](bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](() => this.emit('error', er));\n    }\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      return this[CLOSE](() => this.emit('error', er));\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0;\n        bytesRead++;\n        this.remain++;\n      }\n    }\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);\n    const flushed = this.write(writeBuf);\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]());\n    } else {\n      this[ONDRAIN]();\n    }\n  }\n  [AWAITDRAIN](cb) {\n    this.once('drain', cb);\n  }\n  write(writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected');\n      er.path = this.absolute;\n      return this.emit('error', er);\n    }\n    this.remain -= writeBuf.length;\n    this.blockRemain -= writeBuf.length;\n    this.pos += writeBuf.length;\n    this.offset += writeBuf.length;\n    return super.write(writeBuf);\n  }\n  [ONDRAIN]() {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain));\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end());\n    }\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n      this.offset = 0;\n    }\n    this.length = this.buf.length - this.offset;\n    this[READ]();\n  }\n});\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT]() {\n    this[ONLSTAT](fs.lstatSync(this.absolute));\n  }\n  [SYMLINK]() {\n    this[ONREADLINK](fs.readlinkSync(this.absolute));\n  }\n  [OPENFILE]() {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n  }\n  [READ]() {\n    let threw = true;\n    try {\n      const {\n        fd,\n        buf,\n        offset,\n        length,\n        pos\n      } = this;\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos);\n      this[ONREAD](bytesRead);\n      threw = false;\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {});\n        } catch (er) {}\n      }\n    }\n  }\n  [AWAITDRAIN](cb) {\n    cb();\n  }\n  [CLOSE](cb) {\n    fs.closeSync(this.fd);\n    cb();\n  }\n}\nconst WriteEntryTar = warner(class WriteEntryTar extends Minipass {\n  constructor(readEntry, opt) {\n    opt = opt || {};\n    super(opt);\n    this.preservePaths = !!opt.preservePaths;\n    this.portable = !!opt.portable;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.readEntry = readEntry;\n    this.type = readEntry.type;\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true;\n    }\n    this.prefix = opt.prefix || null;\n    this.path = normPath(readEntry.path);\n    this.mode = this[MODE](readEntry.mode);\n    this.uid = this.portable ? null : readEntry.uid;\n    this.gid = this.portable ? null : readEntry.gid;\n    this.uname = this.portable ? null : readEntry.uname;\n    this.gname = this.portable ? null : readEntry.gname;\n    this.size = readEntry.size;\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;\n    this.atime = this.portable ? null : readEntry.atime;\n    this.ctime = this.portable ? null : readEntry.ctime;\n    this.linkpath = normPath(readEntry.linkpath);\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn);\n    }\n    let pathWarn = false;\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path);\n      if (root) {\n        this.path = stripped;\n        pathWarn = root;\n      }\n    }\n    this.remain = readEntry.size;\n    this.blockRemain = readEntry.startBlockSize;\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    });\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path\n      });\n    }\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath) : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode());\n    }\n    super.write(this.header.block);\n    readEntry.pipe(this);\n  }\n  [PREFIX](path) {\n    return prefixPath(path, this.prefix);\n  }\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable);\n  }\n  write(data) {\n    const writeLen = data.length;\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate');\n    }\n    this.blockRemain -= writeLen;\n    return super.write(data);\n  }\n  end() {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain));\n    }\n    return super.end();\n  }\n});\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\nconst getType = stat => stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\nmodule.exports = WriteEntry;","map":{"version":3,"names":["Minipass","require","Pax","Header","fs","path","normPath","stripSlash","prefixPath","prefix","replace","maxReadSize","PROCESS","Symbol","FILE","DIRECTORY","SYMLINK","HARDLINK","HEADER","READ","LSTAT","ONLSTAT","ONREAD","ONREADLINK","OPENFILE","ONOPENFILE","CLOSE","MODE","AWAITDRAIN","ONDRAIN","PREFIX","HAD_ERROR","warner","winchars","stripAbsolutePath","modeFix","WriteEntry","constructor","p","opt","TypeError","portable","myuid","process","getuid","myuser","env","USER","linkCache","Map","statCache","preservePaths","cwd","strict","noPax","noMtime","mtime","fd","blockLen","blockRemain","buf","offset","length","pos","remain","onwarn","on","pathWarn","root","stripped","win32","platform","decode","absolute","resolve","warn","entry","has","get","emit","ev","data","lstat","er","stat","set","isFile","size","type","getType","end","mode","header","linkpath","uid","gid","uname","atime","ctime","encode","write","dev","ino","nlink","block","slice","readlink","relative","linkKey","indexOf","open","Math","ceil","bufLen","min","Buffer","allocUnsafe","read","bytesRead","cb","close","Error","syscall","code","i","writeBuf","flushed","once","alloc","WriteEntrySync","lstatSync","readlinkSync","openSync","threw","readSync","closeSync","WriteEntryTar","readEntry","gname","startBlockSize","pipe","writeLen","Sync","Tar","isDirectory","isSymbolicLink","module","exports"],"sources":["C:/Users/Ryan/Documents/school/fall 2023/cmpe 133/project/CookChad/frontend/node_modules/tar/lib/write-entry.js"],"sourcesContent":["'use strict'\nconst { Minipass } = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst fs = require('fs')\nconst path = require('path')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path)\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends Minipass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required')\n    }\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath)\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]()\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends Minipass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}