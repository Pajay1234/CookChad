{"ast":null,"code":"'use strict';\n\nconst {\n  Minipass\n} = require('minipass');\nconst normPath = require('./normalize-windows-path.js');\nconst SLURP = Symbol('slurp');\nmodule.exports = class ReadEntry extends Minipass {\n  constructor(header, ex, gex) {\n    super();\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause();\n    this.extended = ex;\n    this.globalExtended = gex;\n    this.header = header;\n    this.startBlockSize = 512 * Math.ceil(header.size / 512);\n    this.blockRemain = this.startBlockSize;\n    this.remain = header.size;\n    this.type = header.type;\n    this.meta = false;\n    this.ignore = false;\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break;\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true;\n        break;\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true;\n    }\n    this.path = normPath(header.path);\n    this.mode = header.mode;\n    if (this.mode) {\n      this.mode = this.mode & 0o7777;\n    }\n    this.uid = header.uid;\n    this.gid = header.gid;\n    this.uname = header.uname;\n    this.gname = header.gname;\n    this.size = header.size;\n    this.mtime = header.mtime;\n    this.atime = header.atime;\n    this.ctime = header.ctime;\n    this.linkpath = normPath(header.linkpath);\n    this.uname = header.uname;\n    this.gname = header.gname;\n    if (ex) {\n      this[SLURP](ex);\n    }\n    if (gex) {\n      this[SLURP](gex, true);\n    }\n  }\n  write(data) {\n    const writeLen = data.length;\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate');\n    }\n    const r = this.remain;\n    const br = this.blockRemain;\n    this.remain = Math.max(0, r - writeLen);\n    this.blockRemain = Math.max(0, br - writeLen);\n    if (this.ignore) {\n      return true;\n    }\n    if (r >= writeLen) {\n      return super.write(data);\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r));\n  }\n  [SLURP](ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k];\n      }\n    }\n  }\n};","map":{"version":3,"names":["Minipass","require","normPath","SLURP","Symbol","module","exports","ReadEntry","constructor","header","ex","gex","pause","extended","globalExtended","startBlockSize","Math","ceil","size","blockRemain","remain","type","meta","ignore","path","mode","uid","gid","uname","gname","mtime","atime","ctime","linkpath","write","data","writeLen","length","Error","r","br","max","slice","global","k","undefined"],"sources":["C:/Users/Ryan/Documents/school/fall 2023/cmpe 133/project/CookChad/frontend/node_modules/tar/lib/read-entry.js"],"sourcesContent":["'use strict'\nconst { Minipass } = require('minipass')\nconst normPath = require('./normalize-windows-path.js')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends Minipass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this[SLURP](ex)\n    }\n    if (gex) {\n      this[SLURP](gex, true)\n    }\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n      }\n    }\n  }\n}\n"],"mappings":"AAAA,YAAY;;AACZ,MAAM;EAAEA;AAAS,CAAC,GAAGC,OAAO,CAAC,UAAU,CAAC;AACxC,MAAMC,QAAQ,GAAGD,OAAO,CAAC,6BAA6B,CAAC;AAEvD,MAAME,KAAK,GAAGC,MAAM,CAAC,OAAO,CAAC;AAC7BC,MAAM,CAACC,OAAO,GAAG,MAAMC,SAAS,SAASP,QAAQ,CAAC;EAChDQ,WAAWA,CAAEC,MAAM,EAAEC,EAAE,EAAEC,GAAG,EAAE;IAC5B,KAAK,CAAC,CAAC;IACP;IACA;IACA;IACA,IAAI,CAACC,KAAK,CAAC,CAAC;IACZ,IAAI,CAACC,QAAQ,GAAGH,EAAE;IAClB,IAAI,CAACI,cAAc,GAAGH,GAAG;IACzB,IAAI,CAACF,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACM,cAAc,GAAG,GAAG,GAAGC,IAAI,CAACC,IAAI,CAACR,MAAM,CAACS,IAAI,GAAG,GAAG,CAAC;IACxD,IAAI,CAACC,WAAW,GAAG,IAAI,CAACJ,cAAc;IACtC,IAAI,CAACK,MAAM,GAAGX,MAAM,CAACS,IAAI;IACzB,IAAI,CAACG,IAAI,GAAGZ,MAAM,CAACY,IAAI;IACvB,IAAI,CAACC,IAAI,GAAG,KAAK;IACjB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,QAAQ,IAAI,CAACF,IAAI;MACf,KAAK,MAAM;MACX,KAAK,SAAS;MACd,KAAK,MAAM;MACX,KAAK,cAAc;MACnB,KAAK,iBAAiB;MACtB,KAAK,aAAa;MAClB,KAAK,WAAW;MAChB,KAAK,MAAM;MACX,KAAK,gBAAgB;MACrB,KAAK,YAAY;QACf;MAEF,KAAK,yBAAyB;MAC9B,KAAK,qBAAqB;MAC1B,KAAK,gBAAgB;MACrB,KAAK,sBAAsB;MAC3B,KAAK,gBAAgB;MACrB,KAAK,mBAAmB;QACtB,IAAI,CAACC,IAAI,GAAG,IAAI;QAChB;;MAEF;MACA;MACA;QACE,IAAI,CAACC,MAAM,GAAG,IAAI;IACtB;IAEA,IAAI,CAACC,IAAI,GAAGtB,QAAQ,CAACO,MAAM,CAACe,IAAI,CAAC;IACjC,IAAI,CAACC,IAAI,GAAGhB,MAAM,CAACgB,IAAI;IACvB,IAAI,IAAI,CAACA,IAAI,EAAE;MACb,IAAI,CAACA,IAAI,GAAG,IAAI,CAACA,IAAI,GAAG,MAAM;IAChC;IACA,IAAI,CAACC,GAAG,GAAGjB,MAAM,CAACiB,GAAG;IACrB,IAAI,CAACC,GAAG,GAAGlB,MAAM,CAACkB,GAAG;IACrB,IAAI,CAACC,KAAK,GAAGnB,MAAM,CAACmB,KAAK;IACzB,IAAI,CAACC,KAAK,GAAGpB,MAAM,CAACoB,KAAK;IACzB,IAAI,CAACX,IAAI,GAAGT,MAAM,CAACS,IAAI;IACvB,IAAI,CAACY,KAAK,GAAGrB,MAAM,CAACqB,KAAK;IACzB,IAAI,CAACC,KAAK,GAAGtB,MAAM,CAACsB,KAAK;IACzB,IAAI,CAACC,KAAK,GAAGvB,MAAM,CAACuB,KAAK;IACzB,IAAI,CAACC,QAAQ,GAAG/B,QAAQ,CAACO,MAAM,CAACwB,QAAQ,CAAC;IACzC,IAAI,CAACL,KAAK,GAAGnB,MAAM,CAACmB,KAAK;IACzB,IAAI,CAACC,KAAK,GAAGpB,MAAM,CAACoB,KAAK;IAEzB,IAAInB,EAAE,EAAE;MACN,IAAI,CAACP,KAAK,CAAC,CAACO,EAAE,CAAC;IACjB;IACA,IAAIC,GAAG,EAAE;MACP,IAAI,CAACR,KAAK,CAAC,CAACQ,GAAG,EAAE,IAAI,CAAC;IACxB;EACF;EAEAuB,KAAKA,CAAEC,IAAI,EAAE;IACX,MAAMC,QAAQ,GAAGD,IAAI,CAACE,MAAM;IAC5B,IAAID,QAAQ,GAAG,IAAI,CAACjB,WAAW,EAAE;MAC/B,MAAM,IAAImB,KAAK,CAAC,2CAA2C,CAAC;IAC9D;IAEA,MAAMC,CAAC,GAAG,IAAI,CAACnB,MAAM;IACrB,MAAMoB,EAAE,GAAG,IAAI,CAACrB,WAAW;IAC3B,IAAI,CAACC,MAAM,GAAGJ,IAAI,CAACyB,GAAG,CAAC,CAAC,EAAEF,CAAC,GAAGH,QAAQ,CAAC;IACvC,IAAI,CAACjB,WAAW,GAAGH,IAAI,CAACyB,GAAG,CAAC,CAAC,EAAED,EAAE,GAAGJ,QAAQ,CAAC;IAC7C,IAAI,IAAI,CAACb,MAAM,EAAE;MACf,OAAO,IAAI;IACb;IAEA,IAAIgB,CAAC,IAAIH,QAAQ,EAAE;MACjB,OAAO,KAAK,CAACF,KAAK,CAACC,IAAI,CAAC;IAC1B;;IAEA;IACA,OAAO,KAAK,CAACD,KAAK,CAACC,IAAI,CAACO,KAAK,CAAC,CAAC,EAAEH,CAAC,CAAC,CAAC;EACtC;EAEA,CAACpC,KAAK,EAAGO,EAAE,EAAEiC,MAAM,EAAE;IACnB,KAAK,MAAMC,CAAC,IAAIlC,EAAE,EAAE;MAClB;MACA;MACA,IAAIA,EAAE,CAACkC,CAAC,CAAC,KAAK,IAAI,IAAIlC,EAAE,CAACkC,CAAC,CAAC,KAAKC,SAAS,IACrC,EAAEF,MAAM,IAAIC,CAAC,KAAK,MAAM,CAAC,EAAE;QAC7B,IAAI,CAACA,CAAC,CAAC,GAAGA,CAAC,KAAK,MAAM,IAAIA,CAAC,KAAK,UAAU,GAAG1C,QAAQ,CAACQ,EAAE,CAACkC,CAAC,CAAC,CAAC,GAAGlC,EAAE,CAACkC,CAAC,CAAC;MACtE;IACF;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}