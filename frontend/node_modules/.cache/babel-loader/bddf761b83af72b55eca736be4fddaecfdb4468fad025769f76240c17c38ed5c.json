{"ast":null,"code":"'use strict';\n\nmodule.exports = validate;\nfunction isArguments(thingy) {\n  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee');\n}\nconst types = {\n  '*': {\n    label: 'any',\n    check: () => true\n  },\n  A: {\n    label: 'array',\n    check: _ => Array.isArray(_) || isArguments(_)\n  },\n  S: {\n    label: 'string',\n    check: _ => typeof _ === 'string'\n  },\n  N: {\n    label: 'number',\n    check: _ => typeof _ === 'number'\n  },\n  F: {\n    label: 'function',\n    check: _ => typeof _ === 'function'\n  },\n  O: {\n    label: 'object',\n    check: _ => typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_)\n  },\n  B: {\n    label: 'boolean',\n    check: _ => typeof _ === 'boolean'\n  },\n  E: {\n    label: 'error',\n    check: _ => _ instanceof Error\n  },\n  Z: {\n    label: 'null',\n    check: _ => _ == null\n  }\n};\nfunction addSchema(schema, arity) {\n  const group = arity[schema.length] = arity[schema.length] || [];\n  if (group.indexOf(schema) === -1) group.push(schema);\n}\nfunction validate(rawSchemas, args) {\n  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length);\n  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas');\n  if (!args) throw missingRequiredArg(1, 'args');\n  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas);\n  if (!types.A.check(args)) throw invalidType(1, ['array'], args);\n  const schemas = rawSchemas.split('|');\n  const arity = {};\n  schemas.forEach(schema => {\n    for (let ii = 0; ii < schema.length; ++ii) {\n      const type = schema[ii];\n      if (!types[type]) throw unknownType(ii, type);\n    }\n    if (/E.*E/.test(schema)) throw moreThanOneError(schema);\n    addSchema(schema, arity);\n    if (/E/.test(schema)) {\n      addSchema(schema.replace(/E.*$/, 'E'), arity);\n      addSchema(schema.replace(/E/, 'Z'), arity);\n      if (schema.length === 1) addSchema('', arity);\n    }\n  });\n  let matching = arity[args.length];\n  if (!matching) {\n    throw wrongNumberOfArgs(Object.keys(arity), args.length);\n  }\n  for (let ii = 0; ii < args.length; ++ii) {\n    let newMatching = matching.filter(schema => {\n      const type = schema[ii];\n      const typeCheck = types[type].check;\n      return typeCheck(args[ii]);\n    });\n    if (!newMatching.length) {\n      const labels = matching.map(_ => types[_[ii]].label).filter(_ => _ != null);\n      throw invalidType(ii, labels, args[ii]);\n    }\n    matching = newMatching;\n  }\n}\nfunction missingRequiredArg(num) {\n  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1));\n}\nfunction unknownType(num, type) {\n  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1));\n}\nfunction invalidType(num, expectedTypes, value) {\n  let valueType;\n  Object.keys(types).forEach(typeCode => {\n    if (types[typeCode].check(value)) valueType = types[typeCode].label;\n  });\n  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' + englishList(expectedTypes) + ' but got ' + valueType);\n}\nfunction englishList(list) {\n  return list.join(', ').replace(/, ([^,]+)$/, ' or $1');\n}\nfunction wrongNumberOfArgs(expected, got) {\n  const english = englishList(expected);\n  const args = expected.every(ex => ex.length === 1) ? 'argument' : 'arguments';\n  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got);\n}\nfunction moreThanOneError(schema) {\n  return newException('ETOOMANYERRORTYPES', 'Only one error type per argument signature is allowed, more than one found in \"' + schema + '\"');\n}\nfunction newException(code, msg) {\n  const err = new Error(msg);\n  err.code = code;\n  /* istanbul ignore else */\n  if (Error.captureStackTrace) Error.captureStackTrace(err, validate);\n  return err;\n}","map":{"version":3,"names":["module","exports","validate","isArguments","thingy","hasOwnProperty","types","label","check","A","_","Array","isArray","S","N","F","O","E","B","Error","Z","addSchema","schema","arity","group","length","indexOf","push","rawSchemas","args","arguments","wrongNumberOfArgs","missingRequiredArg","invalidType","schemas","split","forEach","ii","type","unknownType","test","moreThanOneError","replace","matching","Object","keys","newMatching","filter","typeCheck","labels","map","num","newException","expectedTypes","value","valueType","typeCode","englishList","list","join","expected","got","english","every","ex","code","msg","err","captureStackTrace"],"sources":["C:/Users/Ryan/Documents/school/fall 2023/cmpe 133/project/CookChad/frontend/node_modules/aproba/index.js"],"sourcesContent":["'use strict'\nmodule.exports = validate\n\nfunction isArguments (thingy) {\n  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee')\n}\n\nconst types = {\n  '*': {label: 'any', check: () => true},\n  A: {label: 'array', check: _ => Array.isArray(_) || isArguments(_)},\n  S: {label: 'string', check: _ => typeof _ === 'string'},\n  N: {label: 'number', check: _ => typeof _ === 'number'},\n  F: {label: 'function', check: _ => typeof _ === 'function'},\n  O: {label: 'object', check: _ => typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_)},\n  B: {label: 'boolean', check: _ => typeof _ === 'boolean'},\n  E: {label: 'error', check: _ => _ instanceof Error},\n  Z: {label: 'null', check: _ => _ == null}\n}\n\nfunction addSchema (schema, arity) {\n  const group = arity[schema.length] = arity[schema.length] || []\n  if (group.indexOf(schema) === -1) group.push(schema)\n}\n\nfunction validate (rawSchemas, args) {\n  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length)\n  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas')\n  if (!args) throw missingRequiredArg(1, 'args')\n  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas)\n  if (!types.A.check(args)) throw invalidType(1, ['array'], args)\n  const schemas = rawSchemas.split('|')\n  const arity = {}\n\n  schemas.forEach(schema => {\n    for (let ii = 0; ii < schema.length; ++ii) {\n      const type = schema[ii]\n      if (!types[type]) throw unknownType(ii, type)\n    }\n    if (/E.*E/.test(schema)) throw moreThanOneError(schema)\n    addSchema(schema, arity)\n    if (/E/.test(schema)) {\n      addSchema(schema.replace(/E.*$/, 'E'), arity)\n      addSchema(schema.replace(/E/, 'Z'), arity)\n      if (schema.length === 1) addSchema('', arity)\n    }\n  })\n  let matching = arity[args.length]\n  if (!matching) {\n    throw wrongNumberOfArgs(Object.keys(arity), args.length)\n  }\n  for (let ii = 0; ii < args.length; ++ii) {\n    let newMatching = matching.filter(schema => {\n      const type = schema[ii]\n      const typeCheck = types[type].check\n      return typeCheck(args[ii])\n    })\n    if (!newMatching.length) {\n      const labels = matching.map(_ => types[_[ii]].label).filter(_ => _ != null)\n      throw invalidType(ii, labels, args[ii])\n    }\n    matching = newMatching\n  }\n}\n\nfunction missingRequiredArg (num) {\n  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1))\n}\n\nfunction unknownType (num, type) {\n  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1))\n}\n\nfunction invalidType (num, expectedTypes, value) {\n  let valueType\n  Object.keys(types).forEach(typeCode => {\n    if (types[typeCode].check(value)) valueType = types[typeCode].label\n  })\n  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' +\n    englishList(expectedTypes) + ' but got ' + valueType)\n}\n\nfunction englishList (list) {\n  return list.join(', ').replace(/, ([^,]+)$/, ' or $1')\n}\n\nfunction wrongNumberOfArgs (expected, got) {\n  const english = englishList(expected)\n  const args = expected.every(ex => ex.length === 1)\n    ? 'argument'\n    : 'arguments'\n  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got)\n}\n\nfunction moreThanOneError (schema) {\n  return newException('ETOOMANYERRORTYPES',\n    'Only one error type per argument signature is allowed, more than one found in \"' + schema + '\"')\n}\n\nfunction newException (code, msg) {\n  const err = new Error(msg)\n  err.code = code\n  /* istanbul ignore else */\n  if (Error.captureStackTrace) Error.captureStackTrace(err, validate)\n  return err\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,OAAO,GAAGC,QAAQ;AAEzB,SAASC,WAAWA,CAAEC,MAAM,EAAE;EAC5B,OAAOA,MAAM,IAAI,IAAI,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACC,cAAc,CAAC,QAAQ,CAAC;AACxF;AAEA,MAAMC,KAAK,GAAG;EACZ,GAAG,EAAE;IAACC,KAAK,EAAE,KAAK;IAAEC,KAAK,EAAEA,CAAA,KAAM;EAAI,CAAC;EACtCC,CAAC,EAAE;IAACF,KAAK,EAAE,OAAO;IAAEC,KAAK,EAAEE,CAAC,IAAIC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,IAAIP,WAAW,CAACO,CAAC;EAAC,CAAC;EACnEG,CAAC,EAAE;IAACN,KAAK,EAAE,QAAQ;IAAEC,KAAK,EAAEE,CAAC,IAAI,OAAOA,CAAC,KAAK;EAAQ,CAAC;EACvDI,CAAC,EAAE;IAACP,KAAK,EAAE,QAAQ;IAAEC,KAAK,EAAEE,CAAC,IAAI,OAAOA,CAAC,KAAK;EAAQ,CAAC;EACvDK,CAAC,EAAE;IAACR,KAAK,EAAE,UAAU;IAAEC,KAAK,EAAEE,CAAC,IAAI,OAAOA,CAAC,KAAK;EAAU,CAAC;EAC3DM,CAAC,EAAE;IAACT,KAAK,EAAE,QAAQ;IAAEC,KAAK,EAAEE,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,IAAI,IAAI,IAAI,CAACJ,KAAK,CAACG,CAAC,CAACD,KAAK,CAACE,CAAC,CAAC,IAAI,CAACJ,KAAK,CAACW,CAAC,CAACT,KAAK,CAACE,CAAC;EAAC,CAAC;EAC9GQ,CAAC,EAAE;IAACX,KAAK,EAAE,SAAS;IAAEC,KAAK,EAAEE,CAAC,IAAI,OAAOA,CAAC,KAAK;EAAS,CAAC;EACzDO,CAAC,EAAE;IAACV,KAAK,EAAE,OAAO;IAAEC,KAAK,EAAEE,CAAC,IAAIA,CAAC,YAAYS;EAAK,CAAC;EACnDC,CAAC,EAAE;IAACb,KAAK,EAAE,MAAM;IAAEC,KAAK,EAAEE,CAAC,IAAIA,CAAC,IAAI;EAAI;AAC1C,CAAC;AAED,SAASW,SAASA,CAAEC,MAAM,EAAEC,KAAK,EAAE;EACjC,MAAMC,KAAK,GAAGD,KAAK,CAACD,MAAM,CAACG,MAAM,CAAC,GAAGF,KAAK,CAACD,MAAM,CAACG,MAAM,CAAC,IAAI,EAAE;EAC/D,IAAID,KAAK,CAACE,OAAO,CAACJ,MAAM,CAAC,KAAK,CAAC,CAAC,EAAEE,KAAK,CAACG,IAAI,CAACL,MAAM,CAAC;AACtD;AAEA,SAASpB,QAAQA,CAAE0B,UAAU,EAAEC,IAAI,EAAE;EACnC,IAAIC,SAAS,CAACL,MAAM,KAAK,CAAC,EAAE,MAAMM,iBAAiB,CAAC,CAAC,IAAI,CAAC,EAAED,SAAS,CAACL,MAAM,CAAC;EAC7E,IAAI,CAACG,UAAU,EAAE,MAAMI,kBAAkB,CAAC,CAAC,EAAE,YAAY,CAAC;EAC1D,IAAI,CAACH,IAAI,EAAE,MAAMG,kBAAkB,CAAC,CAAC,EAAE,MAAM,CAAC;EAC9C,IAAI,CAAC1B,KAAK,CAACO,CAAC,CAACL,KAAK,CAACoB,UAAU,CAAC,EAAE,MAAMK,WAAW,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,EAAEL,UAAU,CAAC;EAC5E,IAAI,CAACtB,KAAK,CAACG,CAAC,CAACD,KAAK,CAACqB,IAAI,CAAC,EAAE,MAAMI,WAAW,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,EAAEJ,IAAI,CAAC;EAC/D,MAAMK,OAAO,GAAGN,UAAU,CAACO,KAAK,CAAC,GAAG,CAAC;EACrC,MAAMZ,KAAK,GAAG,CAAC,CAAC;EAEhBW,OAAO,CAACE,OAAO,CAACd,MAAM,IAAI;IACxB,KAAK,IAAIe,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGf,MAAM,CAACG,MAAM,EAAE,EAAEY,EAAE,EAAE;MACzC,MAAMC,IAAI,GAAGhB,MAAM,CAACe,EAAE,CAAC;MACvB,IAAI,CAAC/B,KAAK,CAACgC,IAAI,CAAC,EAAE,MAAMC,WAAW,CAACF,EAAE,EAAEC,IAAI,CAAC;IAC/C;IACA,IAAI,MAAM,CAACE,IAAI,CAAClB,MAAM,CAAC,EAAE,MAAMmB,gBAAgB,CAACnB,MAAM,CAAC;IACvDD,SAAS,CAACC,MAAM,EAAEC,KAAK,CAAC;IACxB,IAAI,GAAG,CAACiB,IAAI,CAAClB,MAAM,CAAC,EAAE;MACpBD,SAAS,CAACC,MAAM,CAACoB,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,EAAEnB,KAAK,CAAC;MAC7CF,SAAS,CAACC,MAAM,CAACoB,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,EAAEnB,KAAK,CAAC;MAC1C,IAAID,MAAM,CAACG,MAAM,KAAK,CAAC,EAAEJ,SAAS,CAAC,EAAE,EAAEE,KAAK,CAAC;IAC/C;EACF,CAAC,CAAC;EACF,IAAIoB,QAAQ,GAAGpB,KAAK,CAACM,IAAI,CAACJ,MAAM,CAAC;EACjC,IAAI,CAACkB,QAAQ,EAAE;IACb,MAAMZ,iBAAiB,CAACa,MAAM,CAACC,IAAI,CAACtB,KAAK,CAAC,EAAEM,IAAI,CAACJ,MAAM,CAAC;EAC1D;EACA,KAAK,IAAIY,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGR,IAAI,CAACJ,MAAM,EAAE,EAAEY,EAAE,EAAE;IACvC,IAAIS,WAAW,GAAGH,QAAQ,CAACI,MAAM,CAACzB,MAAM,IAAI;MAC1C,MAAMgB,IAAI,GAAGhB,MAAM,CAACe,EAAE,CAAC;MACvB,MAAMW,SAAS,GAAG1C,KAAK,CAACgC,IAAI,CAAC,CAAC9B,KAAK;MACnC,OAAOwC,SAAS,CAACnB,IAAI,CAACQ,EAAE,CAAC,CAAC;IAC5B,CAAC,CAAC;IACF,IAAI,CAACS,WAAW,CAACrB,MAAM,EAAE;MACvB,MAAMwB,MAAM,GAAGN,QAAQ,CAACO,GAAG,CAACxC,CAAC,IAAIJ,KAAK,CAACI,CAAC,CAAC2B,EAAE,CAAC,CAAC,CAAC9B,KAAK,CAAC,CAACwC,MAAM,CAACrC,CAAC,IAAIA,CAAC,IAAI,IAAI,CAAC;MAC3E,MAAMuB,WAAW,CAACI,EAAE,EAAEY,MAAM,EAAEpB,IAAI,CAACQ,EAAE,CAAC,CAAC;IACzC;IACAM,QAAQ,GAAGG,WAAW;EACxB;AACF;AAEA,SAASd,kBAAkBA,CAAEmB,GAAG,EAAE;EAChC,OAAOC,YAAY,CAAC,aAAa,EAAE,6BAA6B,IAAID,GAAG,GAAG,CAAC,CAAC,CAAC;AAC/E;AAEA,SAASZ,WAAWA,CAAEY,GAAG,EAAEb,IAAI,EAAE;EAC/B,OAAOc,YAAY,CAAC,cAAc,EAAE,eAAe,GAAGd,IAAI,GAAG,gBAAgB,IAAIa,GAAG,GAAG,CAAC,CAAC,CAAC;AAC5F;AAEA,SAASlB,WAAWA,CAAEkB,GAAG,EAAEE,aAAa,EAAEC,KAAK,EAAE;EAC/C,IAAIC,SAAS;EACbX,MAAM,CAACC,IAAI,CAACvC,KAAK,CAAC,CAAC8B,OAAO,CAACoB,QAAQ,IAAI;IACrC,IAAIlD,KAAK,CAACkD,QAAQ,CAAC,CAAChD,KAAK,CAAC8C,KAAK,CAAC,EAAEC,SAAS,GAAGjD,KAAK,CAACkD,QAAQ,CAAC,CAACjD,KAAK;EACrE,CAAC,CAAC;EACF,OAAO6C,YAAY,CAAC,cAAc,EAAE,YAAY,IAAID,GAAG,GAAG,CAAC,CAAC,GAAG,aAAa,GAC1EM,WAAW,CAACJ,aAAa,CAAC,GAAG,WAAW,GAAGE,SAAS,CAAC;AACzD;AAEA,SAASE,WAAWA,CAAEC,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACC,IAAI,CAAC,IAAI,CAAC,CAACjB,OAAO,CAAC,YAAY,EAAE,QAAQ,CAAC;AACxD;AAEA,SAASX,iBAAiBA,CAAE6B,QAAQ,EAAEC,GAAG,EAAE;EACzC,MAAMC,OAAO,GAAGL,WAAW,CAACG,QAAQ,CAAC;EACrC,MAAM/B,IAAI,GAAG+B,QAAQ,CAACG,KAAK,CAACC,EAAE,IAAIA,EAAE,CAACvC,MAAM,KAAK,CAAC,CAAC,GAC9C,UAAU,GACV,WAAW;EACf,OAAO2B,YAAY,CAAC,gBAAgB,EAAE,WAAW,GAAGU,OAAO,GAAG,GAAG,GAAGjC,IAAI,GAAG,WAAW,GAAGgC,GAAG,CAAC;AAC/F;AAEA,SAASpB,gBAAgBA,CAAEnB,MAAM,EAAE;EACjC,OAAO8B,YAAY,CAAC,oBAAoB,EACtC,iFAAiF,GAAG9B,MAAM,GAAG,GAAG,CAAC;AACrG;AAEA,SAAS8B,YAAYA,CAAEa,IAAI,EAAEC,GAAG,EAAE;EAChC,MAAMC,GAAG,GAAG,IAAIhD,KAAK,CAAC+C,GAAG,CAAC;EAC1BC,GAAG,CAACF,IAAI,GAAGA,IAAI;EACf;EACA,IAAI9C,KAAK,CAACiD,iBAAiB,EAAEjD,KAAK,CAACiD,iBAAiB,CAACD,GAAG,EAAEjE,QAAQ,CAAC;EACnE,OAAOiE,GAAG;AACZ"},"metadata":{},"sourceType":"script","externalDependencies":[]}