{"ast":null,"code":"'use strict';\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\nconst EE = require('events');\nconst Stream = require('stream');\nconst stringdecoder = require('string_decoder');\nconst SD = stringdecoder.StringDecoder;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst defer = fn => Promise.resolve().then(fn);\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n    this.ondrain = () => src[RESUME]();\n    dest.on('drain', this.ondrain);\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n}\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n    this.proxyErrors = er => dest.emit('error', er);\n    src.on('error', this.proxyErrors);\n  }\n}\nclass Minipass extends Stream {\n  constructor(options) {\n    super();\n    this[FLOWING] = false;\n    // whether we're explicitly paused\n    this[PAUSED] = false;\n    this[PIPES] = [];\n    this[BUFFER] = [];\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[ASYNC] = options && !!options.async || false;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this[EMITTED_ERROR] = null;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', {\n        get: () => this[BUFFER]\n      });\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', {\n        get: () => this[PIPES]\n      });\n    }\n    this[SIGNAL] = options && options.signal;\n    this[ABORTED] = false;\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]());\n      if (this[SIGNAL].aborted) {\n        this[ABORT]();\n      }\n    }\n  }\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n  get encoding() {\n    return this[ENCODING];\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk));\n    }\n    this[ENCODING] = enc;\n  }\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n  }\n  get ['async']() {\n    return this[ASYNC];\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true;\n    this.emit('abort', this[SIGNAL].reason);\n    this.destroy(this[SIGNAL].reason);\n  }\n  get aborted() {\n    return this[ABORTED];\n  }\n  set aborted(_) {}\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false;\n    if (this[EOF]) throw new Error('write after end');\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : f => f();\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n    // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this.flowing;\n  }\n  read(n) {\n    if (this[DESTROYED]) return null;\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n    if (this[OBJECTMODE]) n = null;\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')];else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];\n    }\n    const ret = this[READ](n || null, this[BUFFER][0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this[BUFFER][0] = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false;\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n  resume() {\n    return this[RESUME]();\n  }\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n  get destroyed() {\n    return this[DESTROYED];\n  }\n  get flowing() {\n    return this[FLOWING];\n  }\n  get paused() {\n    return this[PAUSED];\n  }\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this[BUFFER].push(chunk);\n  }\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n    return this[BUFFER].shift();\n  }\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');\n  }\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk);\n    return this.flowing;\n  }\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors;\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n    return dest;\n  }\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest);\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));else fn.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true;\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      super.emit(ERROR, data);\n      const ret = !this[SIGNAL] || this.listeners('error').length ? super.emit('error', data) : false;\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n    const ret = super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITEND]() {\n    if (this[EMITTED_END]) return;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    if (this[ASYNC]) defer(() => this[EMITEND2]());else this[EMITEND2]();\n  }\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data);\n        }\n        super.emit('data', data);\n      }\n    }\n    for (const p of this[PIPES]) {\n      p.end();\n    }\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = [];\n    if (!this[OBJECTMODE]) buf.dataLength = 0;\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    return p.then(() => buf);\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength));\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('error', er => reject(er));\n      this.on('end', () => resolve());\n    });\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false;\n    const stop = () => {\n      this.pause();\n      stopped = true;\n      return Promise.resolve({\n        done: true\n      });\n    };\n    const next = () => {\n      if (stopped) return stop();\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return stop();\n      let resolve = null;\n      let reject = null;\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        this.removeListener(DESTROYED, ondestroy);\n        stop();\n        reject(er);\n      };\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.removeListener(DESTROYED, ondestroy);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        this.removeListener(DESTROYED, ondestroy);\n        stop();\n        resolve({\n          done: true\n        });\n      };\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this;\n      }\n    };\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false;\n    const stop = () => {\n      this.pause();\n      this.removeListener(ERROR, stop);\n      this.removeListener(DESTROYED, stop);\n      this.removeListener('end', stop);\n      stopped = true;\n      return {\n        done: true\n      };\n    };\n    const next = () => {\n      if (stopped) return stop();\n      const value = this.read();\n      return value === null ? stop() : {\n        value\n      };\n    };\n    this.once('end', stop);\n    this.once(ERROR, stop);\n    this.once(DESTROYED, stop);\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this;\n      }\n    };\n  }\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n    this[DESTROYED] = true;\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0;\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er);\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED);\n    return this;\n  }\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (\n    // readable\n    typeof s.pipe === 'function' ||\n    // writable\n    typeof s.write === 'function' && typeof s.end === 'function'));\n  }\n}\nexports.Minipass = Minipass;","map":{"version":3,"names":["proc","process","stdout","stderr","EE","require","Stream","stringdecoder","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","defer","fn","Promise","resolve","then","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","end","PipeProxyErrors","er","emit","Minipass","options","objectMode","encoding","async","writable","readable","debugExposeBuffer","Object","defineProperty","get","debugExposePipes","signal","addEventListener","aborted","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","om","a","reason","destroy","_","cb","assign","code","f","from","buffer","byteOffset","flowing","read","n","join","concat","ret","slice","once","resume","pause","destroyed","paused","push","shift","noDrain","pipe","ended","p","find","splice","indexOf","addListener","removeAllListeners","call","emittedEnd","data","extra","listeners","collect","buf","dataLength","promise","c","reject","stopped","stop","done","next","res","value","onerr","ondata","onend","ondestroy","rej","throw","return","close","isStream","s","exports"],"sources":["C:/Users/Ryan/Documents/school/fall 2023/cmpe 133/project/CookChad/frontend/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = require('events')\nconst Stream = require('stream')\nconst stringdecoder = require('string_decoder')\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n    this[SIGNAL] = options && options.signal\n    this[ABORTED] = false\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n      if (this[SIGNAL].aborted) {\n        this[ABORT]()\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL].reason)\n    this.destroy(this[SIGNAL].reason)\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk)\n    return this.flowing\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(DESTROYED, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nexports.Minipass = Minipass\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}