{"ast":null,"code":"const {\n  dirname\n} = require('path');\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false;\n  const parent = dirname(path);\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR') throw er;\n    });\n  }\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT') return mkdirpManual(parent, opts).then(made => mkdirpManual(path, opts, made));\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory()) return made;else throw er;\n    }, () => {\n      throw er;\n    });\n  });\n};\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path);\n  opts.recursive = false;\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts);\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR') throw er;else return;\n    }\n  }\n  try {\n    opts.mkdirSync(path, opts);\n    return made || path;\n  } catch (er) {\n    if (er.code === 'ENOENT') return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;\n    try {\n      if (!opts.statSync(path).isDirectory()) throw er;\n    } catch (_) {\n      throw er;\n    }\n  }\n};\nmodule.exports = {\n  mkdirpManual,\n  mkdirpManualSync\n};","map":{"version":3,"names":["dirname","require","mkdirpManual","path","opts","made","recursive","parent","mkdirAsync","catch","er","code","then","statAsync","st","isDirectory","mkdirpManualSync","mkdirSync","statSync","_","module","exports"],"sources":["C:/Users/Ryan/Documents/school/fall 2023/cmpe 133/project/CookChad/frontend/node_modules/tar/node_modules/mkdirp/lib/mkdirp-manual.js"],"sourcesContent":["const {dirname} = require('path')\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n"],"mappings":"AAAA,MAAM;EAACA;AAAO,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AAEjC,MAAMC,YAAY,GAAGA,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,KAAK;EACzCD,IAAI,CAACE,SAAS,GAAG,KAAK;EACtB,MAAMC,MAAM,GAAGP,OAAO,CAACG,IAAI,CAAC;EAC5B,IAAII,MAAM,KAAKJ,IAAI,EAAE;IACnB,OAAOC,IAAI,CAACI,UAAU,CAACL,IAAI,EAAEC,IAAI,CAAC,CAACK,KAAK,CAACC,EAAE,IAAI;MAC7C;MACA;MACA,IAAIA,EAAE,CAACC,IAAI,KAAK,QAAQ,EACtB,MAAMD,EAAE;IACZ,CAAC,CAAC;EACJ;EAEA,OAAON,IAAI,CAACI,UAAU,CAACL,IAAI,EAAEC,IAAI,CAAC,CAACQ,IAAI,CAAC,MAAMP,IAAI,IAAIF,IAAI,EAAEO,EAAE,IAAI;IAChE,IAAIA,EAAE,CAACC,IAAI,KAAK,QAAQ,EACtB,OAAOT,YAAY,CAACK,MAAM,EAAEH,IAAI,CAAC,CAC9BQ,IAAI,CAACP,IAAI,IAAIH,YAAY,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,CAAC,CAAC;IACjD,IAAIK,EAAE,CAACC,IAAI,KAAK,QAAQ,IAAID,EAAE,CAACC,IAAI,KAAK,OAAO,EAC7C,MAAMD,EAAE;IACV,OAAON,IAAI,CAACS,SAAS,CAACV,IAAI,CAAC,CAACS,IAAI,CAACE,EAAE,IAAI;MACrC,IAAIA,EAAE,CAACC,WAAW,CAAC,CAAC,EAClB,OAAOV,IAAI,MAEX,MAAMK,EAAE;IACZ,CAAC,EAAE,MAAM;MAAE,MAAMA,EAAE;IAAC,CAAC,CAAC;EACxB,CAAC,CAAC;AACJ,CAAC;AAED,MAAMM,gBAAgB,GAAGA,CAACb,IAAI,EAAEC,IAAI,EAAEC,IAAI,KAAK;EAC7C,MAAME,MAAM,GAAGP,OAAO,CAACG,IAAI,CAAC;EAC5BC,IAAI,CAACE,SAAS,GAAG,KAAK;EAEtB,IAAIC,MAAM,KAAKJ,IAAI,EAAE;IACnB,IAAI;MACF,OAAOC,IAAI,CAACa,SAAS,CAACd,IAAI,EAAEC,IAAI,CAAC;IACnC,CAAC,CAAC,OAAOM,EAAE,EAAE;MACX;MACA;MACA,IAAIA,EAAE,CAACC,IAAI,KAAK,QAAQ,EACtB,MAAMD,EAAE,MAER;IACJ;EACF;EAEA,IAAI;IACFN,IAAI,CAACa,SAAS,CAACd,IAAI,EAAEC,IAAI,CAAC;IAC1B,OAAOC,IAAI,IAAIF,IAAI;EACrB,CAAC,CAAC,OAAOO,EAAE,EAAE;IACX,IAAIA,EAAE,CAACC,IAAI,KAAK,QAAQ,EACtB,OAAOK,gBAAgB,CAACb,IAAI,EAAEC,IAAI,EAAEY,gBAAgB,CAACT,MAAM,EAAEH,IAAI,EAAEC,IAAI,CAAC,CAAC;IAC3E,IAAIK,EAAE,CAACC,IAAI,KAAK,QAAQ,IAAID,EAAE,CAACC,IAAI,KAAK,OAAO,EAC7C,MAAMD,EAAE;IACV,IAAI;MACF,IAAI,CAACN,IAAI,CAACc,QAAQ,CAACf,IAAI,CAAC,CAACY,WAAW,CAAC,CAAC,EACpC,MAAML,EAAE;IACZ,CAAC,CAAC,OAAOS,CAAC,EAAE;MACV,MAAMT,EAAE;IACV;EACF;AACF,CAAC;AAEDU,MAAM,CAACC,OAAO,GAAG;EAACnB,YAAY;EAAEc;AAAgB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}