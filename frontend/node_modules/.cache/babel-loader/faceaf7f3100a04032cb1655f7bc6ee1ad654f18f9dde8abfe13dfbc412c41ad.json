{"ast":null,"code":"// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];\nif (process.platform !== 'win32') {\n  module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'\n  // should detect profiler and enable/disable accordingly.\n  // see #21\n  // 'SIGPROF'\n  );\n}\n\nif (process.platform === 'linux') {\n  module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');\n}","map":{"version":3,"names":["module","exports","process","platform","push"],"sources":["C:/Users/Ryan/Documents/school/fall 2023/cmpe 133/project/CookChad/frontend/node_modules/signal-exit/signals.js"],"sourcesContent":["// This is not the set of all possible signals.\r\n//\r\n// It IS, however, the set of all signals that trigger\r\n// an exit on either Linux or BSD systems.  Linux is a\r\n// superset of the signal names supported on BSD, and\r\n// the unknown signals just fail to register, so we can\r\n// catch that easily enough.\r\n//\r\n// Don't bother with SIGKILL.  It's uncatchable, which\r\n// means that we can't fire any callbacks anyway.\r\n//\r\n// If a user does happen to register a handler on a non-\r\n// fatal signal like SIGWINCH or something, and then\r\n// exit, it'll end up firing `process.emit('exit')`, so\r\n// the handler will be fired anyway.\r\n//\r\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\r\n// artificially, inherently leave the process in a\r\n// state from which it is not safe to try and enter JS\r\n// listeners.\r\nmodule.exports = [\r\n  'SIGABRT',\r\n  'SIGALRM',\r\n  'SIGHUP',\r\n  'SIGINT',\r\n  'SIGTERM'\r\n]\r\n\r\nif (process.platform !== 'win32') {\r\n  module.exports.push(\r\n    'SIGVTALRM',\r\n    'SIGXCPU',\r\n    'SIGXFSZ',\r\n    'SIGUSR2',\r\n    'SIGTRAP',\r\n    'SIGSYS',\r\n    'SIGQUIT',\r\n    'SIGIOT'\r\n    // should detect profiler and enable/disable accordingly.\r\n    // see #21\r\n    // 'SIGPROF'\r\n  )\r\n}\r\n\r\nif (process.platform === 'linux') {\r\n  module.exports.push(\r\n    'SIGIO',\r\n    'SIGPOLL',\r\n    'SIGPWR',\r\n    'SIGSTKFLT',\r\n    'SIGUNUSED'\r\n  )\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAG,CACf,SAAS,EACT,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,SAAS,CACV;AAED,IAAIC,OAAO,CAACC,QAAQ,KAAK,OAAO,EAAE;EAChCH,MAAM,CAACC,OAAO,CAACG,IAAI,CACjB,WAAW,EACX,SAAS,EACT,SAAS,EACT,SAAS,EACT,SAAS,EACT,QAAQ,EACR,SAAS,EACT;EACA;EACA;EACA;EACF,CAAC;AACH;;AAEA,IAAIF,OAAO,CAACC,QAAQ,KAAK,OAAO,EAAE;EAChCH,MAAM,CAACC,OAAO,CAACG,IAAI,CACjB,OAAO,EACP,SAAS,EACT,QAAQ,EACR,WAAW,EACX,WACF,CAAC;AACH"},"metadata":{},"sourceType":"script","externalDependencies":[]}